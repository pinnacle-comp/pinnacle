syntax = "proto2";

package pinnacle.signal.v0alpha1;

import "google/protobuf/empty.proto";

enum Signal {
  SIGNAL_UNSPECIFIED = 0;
  SIGNAL_INPUT_POINTER_BUTTON = 1;
  SIGNAL_INPUT_POINTER_MOTION = 2;
  SIGNAL_INPUT_POINTER_AXIS = 3;
  SIGNAL_INPUT_KEYBOARD = 4;

  SIGNAL_WINDOW_POINTER_ENTER = 5;
  SIGNAL_WINDOW_POINTER_LEAVE = 6;
  SIGNAL_WINDOW_OPEN = 7;
  SIGNAL_WINDOW_CLOSE = 8;
  SIGNAL_WINDOW_FULLSCREEN = 9;
  SIGNAL_WINDOW_MAXIMIZE = 10;
  SIGNAL_WINDOW_FLOATING = 11;
  SIGNAL_WINDOW_MOVE = 12;
  SIGNAL_WINDOW_RESIZE = 13;

  SIGNAL_OUTPUT_CONNECT = 14;
  SIGNAL_OUTPUT_DISCONNECT = 15;
  SIGNAL_OUTPUT_MOVE = 16;

  SIGNAL_TAG_ADD = 17;
  SIGNAL_TAG_REMOVE = 18;
  SIGNAL_TAG_ACTIVE = 19;
  SIGNAL_TAG_WINDOW_TAGGED = 20;
  SIGNAL_TAG_WINDOW_UNTAGGED = 21;
}

enum State {
  STATE_UNSPECIFIED = 0;
  STATE_PRESS = 1;
  STATE_RELEASE = 2;
}

message InputPointerButton {
  // NULLABLE
  //
  // The window that received the button event.
  optional uint32 window_id = 1;

  // The numerical code of the button, given by one of the
  // `BTN_` constants in `input-event-codes.h`.
  optional uint32 code = 2;
  // Whether the button was pressed or released.
  optional State state = 3;
  // The mouse x-coord in the global space at the time of the event.
  optional double x = 4;
  // The mouse y-coord in the global space at the time of the event.
  optional double y = 5;
}

message InputPointerMotion {
  // NULLABLE
  //
  // The window the pointer is over.
  optional uint32 window_id = 1;

  // The pointer's current x-coordinate.
  optional double x = 2;
  // The pointer's current y-coordinate.
  optional double y = 3;
  // The pointer's relative x motion.
  optional double rel_x = 4;
  // The pointer's relative y motion.
  optional double rel_y = 5;
}

message InputPointerAxis {
  // NULLABLE
  //
  // The window that received the axis event.
  optional uint32 window_id = 1;

  // The amount the device scrolled vertically.
  //
  // A value of 3.0 corresponds to one scroll wheel detent.
  optional double vertical_value = 2;
  // The amount the device scrolled horizontally.
  //
  // A value of 3.0 corresponds to one scroll wheel detent.
  optional double horizontal_value = 3;
  // The amount the device scrolled vertically, in discrete steps.
  //
  // A value of 120 corresponds to one scroll wheel detent.
  optional int32 vertical_value_discrete = 4;
  // The amount the device scrolled horizontally, in discrete steps.
  //
  // A value of 120 corresponds to one scroll wheel detent.
  optional int32 horizontal_value_discrete = 5;
}

message InputKeyboard {
  // NULLABLE
  //
  // The window that received the keyboard event.
  //
  // This will only have a window_id if the window has keyboard focus
  // and the input is not eaten by the compositor.
  optional uint32 window_id = 1;

  optional uint32 code = 2;
  optional State state = 3;
  repeated uint32 raw_keysyms = 4;
  repeated uint32 modified_keysyms = 5;
}

message WindowPointerEnter {
  optional uint32 window_id = 1;
}

message WindowPointerLeave {
  optional uint32 window_id = 1;
}

message WindowOpen {
  optional uint32 window_id = 1;
}

message WindowClose {
  optional uint32 window_id = 1;
}

message WindowFullscreen {
  optional uint32 window_id = 1;
  optional bool fullscreen = 2;
}

message WindowMaximize {
  optional uint32 window_id = 1;
  optional bool maximize = 2;
}

message WindowFloating {
  optional uint32 window_id = 1;
  optional bool floating = 2;
}

message WindowMove {
  optional uint32 window_id = 1;
  optional int32 x = 2;
  optional int32 y = 3;
}

message WindowResize {
  optional uint32 window_id = 1;
  optional uint32 width = 2;
  optional uint32 height = 3;
}

message OutputConnect {
  optional string output_name = 1;
}

message OutputDisconnect {
  optional string output_name = 1;
}

message OutputMove {
  optional string output_name = 1;
  optional int32 x = 2;
  optional int32 y = 3;
}

message TagAdd {
  optional uint32 tag_id = 1;
}

message TagRemove {
  optional uint32 tag_id = 1;
}

message TagActive {
  optional uint32 tag_id = 1;
  optional bool active = 2;
}

message TagWindowTagged {
  optional uint32 tag_id = 1;
  optional uint32 window_id = 2;
}

message TagWindowUntagged {
  optional uint32 tag_id = 1;
  optional uint32 window_id = 2;
}

message ConnectSignalRequest {
  optional Signal signal = 1;
}

message DisconnectSignalRequest {
  optional Signal signal = 1;
}

message ListenRequest {}

message ListenResponse {
  oneof signal {
    InputPointerButton input_pointer_button = 1;
    InputPointerMotion input_pointer_motion = 2;
    InputPointerAxis input_pointer_axis = 3;
    InputKeyboard input_keyboard = 4;

    WindowPointerEnter window_pointer_enter = 5;
    WindowPointerLeave window_pointer_leave = 6;
    WindowOpen window_open = 7;
    WindowClose window_close = 8;
    WindowFullscreen window_fullscreen = 9;
    WindowMaximize window_maximize = 10;
    WindowFloating window_floating = 11;
    WindowMove window_move = 12;
    WindowResize window_resize = 13;

    OutputConnect output_connect = 14;
    OutputDisconnect output_disconnect = 15;
    OutputMove output_move = 16;
 
    // FIXME: Need to send ack for stuff like OutputDisconnect and TagRemove

    TagAdd tag_add = 17;
    TagRemove tag_remove = 18;
    TagActive tag_active = 19;
    TagWindowTagged tag_window_tagged = 20;
    TagWindowUntagged tag_window_untagged = 21;
  }
}

service SignalService {
  // Notify the compositor that this client requests to connect the given
  // signal.
  //
  // The compositor will begin sending relevant signals through the stream.
  rpc ConnectSignal(ConnectSignalRequest) returns (google.protobuf.Empty);

  // Notify the compositor that this client wishes to stop receiving signals
  // for the given signal.
  //
  // Handling of when to disconnect should be implemented on a per-client basis.
  // This would normally be when the user has disconnected all signals of the
  // given type.
  rpc DisconnectSignal(DisconnectSignalRequest) returns (google.protobuf.Empty);

  // Listen for incoming signals.
  //
  // The compositor will send signals through the returned stream for any
  // signal the client has explicitly `Connect`ed.
  rpc Listen(ListenRequest) returns (stream ListenResponse);
}
